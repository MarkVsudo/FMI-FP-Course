**Задача 1.** Нека са дефинирани:
`type PersonID = Int`
`type Name = String`
`type City = String`
`type AccountID = Int`
`type Balance = Double`
`type Person = (PersonID, Name, City)`
`type Account = (AccountID, PersonID, Balance)`
Дефинирайте функцията `getCriticalBalance :: ([Account], [Person]) -> (Person -> Bool) -> Balance -> [(PersonID, Balance)]`. Функцията получава като първи аргумент база от данни `database`, представена като двойка от списък от сметки и списък от хора. Вторият аргумент е предикат `p`, а третият е критична стойност `s` на баланс. Функцията `getCriticalBalance` трябва да връща списък от двойки от идентификатор на човек (`PersonID`) и сума на баланс по всички сметки за конкретния `PersonID`. Върнатият списък трябва да съдържа всички хора, които удовлетворяват предиката `p` и за които сумата на баланса по всички сметки е по-малка от `s`. Всяка сметка е вектор с три елемента: идентификатор на сметка, идентификатор на човек и баланс по сметката. Всеки човек е представен като вектор от три елемента, съответно: идентификатор на човек, име и местоживеене.
*Примери:*
`db = ([(1, 1, 10), (2, 1, 11), (3, 1, 12), (4, 2, 3), (5, 2, 1), (6, 3, 2), (7, 3, 3), (8, 4, 12)], [(1, "Ivan", "Varna"), (2, "Petar", "Burgas"), (3, "Georgi", "Varna"), (4, "Yordan", "Plovdiv")])`

`fromVarna :: Person -> Bool`
`fromVarna (_, _, "Varna") = True`
`fromVarna _ = False`

`getCriticalBalance db fromVarna         10 → [(3,5.0)] `
`getCriticalBalance db (not . fromVarna) 15 → [(2,4.0),(4,12.0)]`

**Задача 2.** Даден е списък от двойки, представящи оценките на ученици от даден клас по даден предмет. Първият елемент на всяка двойка е номерът на ученика в класа, а вторият - получената оценка по предмета (приемаща стойности от 0 до 100). Да се дефинира функция `studAvg :: [(Int, Double)] -> [(Int, Double)]`, която приема списък от горепосочения вид и изчислява средната стойност на най-добрите пет оценки на всеки ученик. Резултатът да е сортиран спрямо номерата на учениците. Може да се приеме, че всеки ученик има поне пет оценки.
*Примери:*
`studAvg [(1, 100), (1, 50), (2, 100), (2, 93), (1, 39), (2, 87), (1, 89), (1, 87), (1, 90), (2, 100), (2, 76)] → [(1, 83.2), (2, 91.2)]`
`studAvg [(3, 55), (2, 50), (1, 21), (3, 53), (2, 48), (1, 3), (3, 4), (2, 28), (1, 10), (3, 80), (2, 68), (1, 15), (3, 91), (2, 45), (1, 49)] → [(1,19.6),(2,47.8),(3,56.6)]`

**Задача 3.** Палиндромът е число, което се чете по един и същ начин отляво надясно и отдясно наляво. Дефинирайте функция `findMaxPalindrome :: Integer -> Integer`, която получава естествено число `n` и връща като резултат най-големия палиндром, който може да се състави от някои от цифрите на числото `n`.
*Примери:*
`findMaxPalindrome 1112332 → 3211123`
`findMaxPalindrome 22220   → 22022`
`findMaxPalindrome 2205    → 252`
`findMaxPalindrome 120021  → 210012`
`findMaxPalindrome 12320   → 232`
`findMaxPalindrome 123     → 3`
