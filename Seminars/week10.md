**Задача 1.** Да се дефинира функция `listOfIndexes :: Int -> [Int] -> [Int]`, която получава естествено число `n` и списък `xs` и връща списък от индексите (поредните номера) на елементите на `xs`, които са равни на `n`. Предполага се, че индексирането на елементите на списъка започва от `0`.

Примери:

`listOfIndexes 3 [1,2,3,4,3,5,3,2,1] → [2,4,6]`

`listOfIndexes 4 [1,2,3,2,1,2,3,2,1] → []`

**Задача 2.** Според основната теорема на аритметиката, всяко естествено число, по-голямо от `1`, може да се представи като произведение на прости числа. Да се дефинира функция `factorize :: Int -> [Int]`, която приема естествено число, по-голямо от `1`, и връща сортиран списък от елементите на това представяне.

Примери:

`factorize 13 → [13]`

`factorize 152 → [2,2,2,19]`

`factorize 123 → [3,41]`

**Задача 3.** Да се дефинира функция `averageFunction fs`, която за даден непразен списък от едноаргументни аритметични функции `fs = [f1,f2, … , fn]` връща като резултат функция, чиято стойност в дадена точка `x` се получава като средното аритметично на стойностите на функциите от `fs` в тази точка.

Пример:

`(averageFunction [(+1),(**0.5),(2**)]) 2 → 2.804738`

**Задача 4.** Да се дефинира функция `singleCousin tree`, която за дадено двоично дърво от цели числа `tree` връща списък от всички върхове на `tree`, които имат единствен първи братовчед. Под формата на коментар опишете избраното от вас представяне на двоично дърво и посочете как се представя дървото от примера.

Пример:

Нека `tree` има стойност, съответна на избраното представяне на двоичното дърво

```
         1 
      /     \ 
     2       3
    / \     / \
   4   5   6    7 
  / \   \   \    \ 
 8   9   10  11   12 
```

Тогава `singleCousin tree → [8,9,11,12]`

**Задача 5.** Казваме, че едно двоично дърво е конус, ако сумата на върховете на всяко ниво на дървото е по-голяма от сумата на върховете на предишното ниво. Като се използва следното представяне на двоично дърво:

`data BTree = Empty | Node Int BTree BTree`

a) Да се дефинира функция `levelsum t k`, която намира сумата на върховете на ниво `k` в двоичното дърво `t`.

b) Да се дефинира функция `cone t`, която проверява дали двоичното дърво `t` е конус.
